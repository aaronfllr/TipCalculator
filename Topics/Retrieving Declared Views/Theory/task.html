<h2>Retrieving Declared Views</h2>
<div class="step-text">
<p>You already know how to declare views in XML files. You also know that you can declare initial values for the attributes of each view you declare. However, what if you want to initialize or change those attributes during the execution of the app? For example, you may want to initialize a certain text value to the result of some calculation or procedure, like retrieving a username from a database. Or, you may need to set listeners for events, such as button clicks, and react to those.</p>
<p>The simplest and most reliable way to access the views declared in your XML files is using the <code class="language-xml">findViewById</code> method.</p>
<h5 id="declaring-an-id-for-your-view-in-an-xml-file">Declaring an ID for your view in an XML file</h5>
<p>To be able to retrieve a view declared in an XML file, you will first need to set an <code class="language-xml">id</code> attribute to the view you wish to access.</p>
<pre><code class="language-xml">
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;LinearLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"&gt;

    &lt;TextView
        android:id="@+id/someTextViewId"
        tools:text="placeholder text"
        android:textSize="32sp"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:layout_margin="8dp"
        android:gravity="center"/&gt;
&lt;/LinearLayout&gt;
</code></pre>
<p>Above, we have an example with a really simple layout, which includes one TextView. The ID of that <code class="language-xml">TextView</code> is set to <code class="language-xml">someTextViewId</code> with the following attribute declaration: <code class="language-xml">android:id="@+id/someTextViewId</code>.</p>
<p>That is all we will need to do in the XML file. You can set IDs for any of your views, including layouts, for as many views as you want. It is a harmful practice to set multiple views with the same ID, so you should avoid doing that.</p>
<h5 id="retrieving-views-to-local-variables">Retrieving views to local variables</h5>
<p>Now, let us try to access the view we've declared in XML to programmatically make some changes to it. Look at some examples of how that can be achieved:</p>
<pre><code class="language-kotlin">override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)

     // val beforeSetContentView: View = findViewById(R.id.someTextViewId)
     // example0, throws error

        setContentView(R.layout.activity_name)
     // must be called before any findViewById call

        val someView: View? = findViewById(R.id.someTextViewId) // example1
        val someTextView = findViewById&lt;TextView&gt;(R.id.someTextViewId)  // example2
        ...
}</code></pre>
<p>The first thing we should acknowledge is that IDs declared in XML will be available as properties of the <code class="language-xml">R.id</code> class. That means we can make a reference to the ID we declared in our XML example with <code class="language-xml">R.id.someTextViewId</code>. If you look at the signature of <code class="language-xml">findViewById</code>, you will see it expects an <code class="language-xml">Int</code> to be passed as an argument. That is because technically, an ID is just an integer number and its value is automatically generated by AAPT (Android asset packaging tool) during compile time.</p>
<p>Now, let's talk about the differences between example0, example1, and example2.</p>
<p>In example0, we will receive the following error: <code class="language-xml">java.lang.NullPointerException: findViewById(R.id.someTextViewId) must not be null</code>.</p>
<p>The reason for that error is that you are only able to retrieve the views that already exist, which won’t happen until <code class="language-xml">setContentView(R.layout.activity_name)</code> is called. The method <code class="language-xml">setContentView</code> is responsible for bringing the views declared in XML into existence by a procedure called <strong>inflation</strong>, which will be considered in more detail in a future topic. If a view is not found, <code class="language-xml">findViewById</code> will return <code class="language-xml">null</code>. In example0, the <code class="language-xml">NullPointerException</code> is thrown because we were expecting a non-nullable value.</p>
<p>Let’s now look at example1. Here, we are declaring a more generic <code class="language-xml">View</code> type – and declaring it as nullable. This is not how it is usually done, though, for a number of reasons.</p>
<p>The first reason is that you usually won't be calling <code class="language-xml">findViewById</code> with an unexisting ID, since your code won't compile if you reference one, like <code class="language-xml">R.id.someUnexistingViewId</code>. For that reason, you usually don't need to worry about null values being returned from <code class="language-xml">findViewById</code>. Since it is just easier to work with non-nullable values, that is a preferable way. If, for some reason, you are not sure that the view you are looking for is going to be found, then you should declare a nullable type instead; however, that is not the most usual case.</p>
<p>The second reason is that you will usually be willing to use specific methods of a particular view class you've declared. This means it is preferable to declare your variable with that specific class instead of using a more generic class. For that reason, looking at our example, using <code class="language-xml">TextView</code> rather than <code class="language-xml">View</code> would be preferable.</p>
<p>In example2, we have an opposite to example1. That means example2 is the common way of using <code class="language-xml">findViewById</code> to declare local variables. The reasons for that are the same as those already discussed for example1.</p>
<p>An attentive reader might have noticed another difference between example1 and example2. In example1, we are declaring the type on the left side of the assignment, and in example2, we are passing the type information on the right side, inside the angle brackets. Both ways are equally good. You could also pass the information on both sides, but you cannot omit the information on both sides, as that would be a compilation error: <code class="language-xml">Not enough information to infer type variable T</code>.</p>
<p>The reason for this error is that <code class="language-xml">findViewById</code> is a generic function and the Kotlin compiler has to know the type argument for a function at compile time. In example1, the compiler is smart enough to infer the type information the function needs by looking at the type you are declaring for your variable on the left side of the assignment. In example2, we have it the other way around: here the type argument is passed directly to <code class="language-xml">findViewById</code>.</p>
<h5 id="declaring-views-as-properties">Declaring views as properties</h5>
<p>Ok, we have learned how to retrieve our views as local variables. However, we don't want to redeclare variables for each method of our Activity class; besides, it is inconvenient to pass these views around as arguments. It's a better idea to declare properties right in our Activity class to hold those views, but wait, how can we do that if we need to call <code class="language-xml">setContentView(R.layout.activity_name)</code> before being able to call <code class="language-xml">findViewById</code>?</p>
<p>Let's see another code example. Assume that all used views were previously declared in the appropriate XML file.</p>
<pre><code class="language-kotlin">
var someButton: Button? = null    // example3
lateinit var someEditText: EditText  // example4
val someImageView: ImageView by lazy { findViewById(R.id.someImageViewId) } // example5

...

override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_name)
        someButton = findViewById(R.id.someButtonId) // example3
        someEditText = findViewById(R.id.someEditTextId) // example4
        someImageView // example5
        ...
}</code></pre>
<p>The code used in example3 is quite straightforward, but it is not common because working with nullable properties is a little less convenient than using non-nullable ones.</p>
<p>The pattern used in example4, with <code class="language-xml">lateinit var</code>, is the most common one you will come across. It is really important here to make sure the property is initialized before being read. Otherwise, you'll get an <code class="language-xml">UninitializedPropertyAccessException</code> and your application will crash. For this reason, it is a good practice to initialize properties declared with <code class="language-xml">lateinit</code> right after calling <code class="language-xml">setContentView</code> in the <code class="language-xml">onCreate</code> method.</p>
<p>If you are the kind of programmer who avoids <code class="language-xml">var</code> as much as you can because you value immutability and the benefits it brings to your code, then you might want to use the pattern from example5. In this case, a property will be initialized when it's first used. To be honest, it brings a lot of overhead for property delegation, access synchronization, and keeping initializer lambda code, while bringing no benefit over <code class="language-xml">lateinit</code>: access before <code class="language-xml">setContentView</code> would still lead to a crash. Thus, this pattern is undesirable and should be avoided.</p>
<h5 id="other-classes-that-have-findviewbyid">Other classes that have <code class="language-xml">findViewById</code></h5>
<p>Besides <code class="language-xml">Activity</code>, there are also other classes that contain the <code class="language-xml">findViewById</code> method, like <code class="language-xml">View</code> and <code class="language-xml">Dialog</code>.</p>
<p>It is good to keep in mind that you can find an existing view only if it is contained in the object whose <code class="language-xml">findViewById</code> is called.</p>
<p>The <code class="language-xml">View.findViewById</code> can be useful if you are already holding a reference to some <code class="language-xml">ViewGroup</code>, like <code class="language-xml">GridLayout</code> or <code class="language-xml">CardView</code>, and wish to retrieve a view it contains.</p>
<p><code class="language-xml">Dialog.findViewById</code> may be useful if you have a dialog with a custom XML layout.</p>
<h5 id="conclusion">Conclusion</h5>
<p>In this topic, we have learned how to use the method <code class="language-xml">findViewById</code> to retrieve views declared in XML files in our Activities. We've learned that we should make sure our views exist before calling <code class="language-xml">findViewById</code>. We have also looked at several possible ways to declare local variables holding views and several ways to declare properties initialized with this method. We've discussed their pros and cons and pointed out most common practices.</p>
<p>Finally, we have also briefly noted that there are other classes besides Activity that also have a method called <code class="language-xml">findViewById</code> with the same general purpose of retrieving views.</p>
</div>
